-- Copyright (c) 2020-2021 Maarten Baert <info@maartenbaert.be>
-- Available under the MIT License - see LICENSE.txt for details.

-- This file was generated by `generate_vhdl.py`.

library ieee;
use ieee.std_logic_1164.all;

entity xormix32 is
    generic (
        streams : integer range 1 to 32 := 1
    );
    port (
        
        -- clock and synchronous reset
        clk    : in std_logic;
        rst    : in std_logic;
        
        -- configuration
        seed_x : in std_logic_vector(31 downto 0);
        seed_y : in std_logic_vector(32 * streams - 1 downto 0);
        
        -- random number generator
        enable : in std_logic;
        result : out std_logic_vector(32 * streams - 1 downto 0)
        
    );
end xormix32;

architecture rtl of xormix32 is
    
    type salts_t is array(0 to 31) of std_logic_vector(31 downto 0);
    constant salts : salts_t := (
        x"198f8d32", x"46d9b8ac", x"57f90206", x"cb246290",
        x"5fda94c2", x"b9969e83", x"990053fe", x"0cef1f8b",
        x"9baafefa", x"232b8463", x"0fc77197", x"d113a2d8",
        x"d6c99ef7", x"f3fb7189", x"9ceeb1dd", x"352df180",
        x"feed780c", x"ee211518", x"3afaca18", x"95f13c50",
        x"d8449f2a", x"59752549", x"854f0980", x"234a07b4",
        x"51c0c69b", x"a71d489e", x"618cbc79", x"ab0e51e1",
        x"965c4507", x"e90488a4", x"73674eb7", x"00af1456"
    );
    
    signal r_state_x : std_logic_vector(31 downto 0);
    signal r_state_y : std_logic_vector(32 * streams - 1 downto 0);
    
begin
    
    result <= r_state_y;
    
    process (clk)
        
        variable v_state_y : std_logic_vector(32 * streams - 1 downto 0);
        
        variable v_mixin : std_logic_vector(31 downto 0);
        variable v_mixup : std_logic_vector(31 downto 0);
        variable v_res : std_logic_vector(15 downto 0);
        
    begin
        if rising_edge(clk) then
            if rst = '1' then
                
                r_state_x <= seed_x;
                r_state_y <= seed_y;
                
            elsif enable = '1' then
                
                r_state_x( 0) <= r_state_x(11) xor r_state_x(24) xor r_state_x(22) xor r_state_x( 3) xor r_state_x(19);
                r_state_x( 1) <= r_state_x(25) xor r_state_x( 7) xor r_state_x(20) xor r_state_x( 2) xor r_state_x(26) xor r_state_x(28);
                r_state_x( 2) <= r_state_x( 8) xor r_state_x( 5) xor r_state_x(18) xor r_state_x(24) xor r_state_x( 4);
                r_state_x( 3) <= r_state_x( 8) xor r_state_x(22) xor r_state_x(26) xor r_state_x( 7) xor r_state_x(21) xor r_state_x(14);
                r_state_x( 4) <= r_state_x(30) xor r_state_x(26) xor r_state_x(25) xor r_state_x(14) xor r_state_x(24);
                r_state_x( 5) <= r_state_x(21) xor r_state_x(10) xor r_state_x(16) xor r_state_x(13) xor r_state_x( 5) xor r_state_x(17);
                r_state_x( 6) <= r_state_x(14) xor r_state_x(29) xor r_state_x(24) xor r_state_x(11) xor r_state_x(25);
                r_state_x( 7) <= r_state_x( 5) xor r_state_x(26) xor r_state_x(31) xor r_state_x(22) xor r_state_x(27) xor r_state_x( 7);
                r_state_x( 8) <= r_state_x( 0) xor r_state_x(17) xor r_state_x( 1) xor r_state_x(18) xor r_state_x( 8);
                r_state_x( 9) <= r_state_x(29) xor r_state_x( 0) xor r_state_x(21) xor r_state_x(26) xor r_state_x( 3) xor r_state_x(13);
                r_state_x(10) <= r_state_x(23) xor r_state_x(29) xor r_state_x(19) xor r_state_x(21) xor r_state_x(10);
                r_state_x(11) <= r_state_x(19) xor r_state_x(20) xor r_state_x( 4) xor r_state_x(18) xor r_state_x(15) xor r_state_x(10);
                r_state_x(12) <= r_state_x(28) xor r_state_x(29) xor r_state_x(24) xor r_state_x(19) xor r_state_x( 4);
                r_state_x(13) <= r_state_x(19) xor r_state_x( 6) xor r_state_x(27) xor r_state_x(12) xor r_state_x(11) xor r_state_x( 7);
                r_state_x(14) <= r_state_x( 1) xor r_state_x( 5) xor r_state_x( 3) xor r_state_x(30) xor r_state_x(25);
                r_state_x(15) <= r_state_x(22) xor r_state_x(12) xor r_state_x(11) xor r_state_x( 7) xor r_state_x(28) xor r_state_x( 1);
                r_state_x(16) <= r_state_x(16) xor r_state_x( 5) xor r_state_x(29) xor r_state_x( 2) xor r_state_x(14);
                r_state_x(17) <= r_state_x( 8) xor r_state_x(24) xor r_state_x( 0) xor r_state_x(23) xor r_state_x(31) xor r_state_x(26);
                r_state_x(18) <= r_state_x(15) xor r_state_x(17) xor r_state_x( 4) xor r_state_x( 9) xor r_state_x( 6);
                r_state_x(19) <= r_state_x(30) xor r_state_x( 9) xor r_state_x(18) xor r_state_x( 2) xor r_state_x(11) xor r_state_x( 6);
                r_state_x(20) <= r_state_x( 2) xor r_state_x(27) xor r_state_x(15) xor r_state_x(12) xor r_state_x(20);
                r_state_x(21) <= r_state_x(21) xor r_state_x(20) xor r_state_x(10) xor r_state_x( 6) xor r_state_x(31) xor r_state_x( 1);
                r_state_x(22) <= r_state_x( 9) xor r_state_x(29) xor r_state_x(15) xor r_state_x(27) xor r_state_x(16);
                r_state_x(23) <= r_state_x(29) xor r_state_x(10) xor r_state_x(31) xor r_state_x(30) xor r_state_x(13) xor r_state_x( 3);
                r_state_x(24) <= r_state_x(31) xor r_state_x(23) xor r_state_x( 6) xor r_state_x(24) xor r_state_x(17);
                r_state_x(25) <= r_state_x( 4) xor r_state_x( 8) xor r_state_x( 6) xor r_state_x(19) xor r_state_x(16) xor r_state_x( 9);
                r_state_x(26) <= r_state_x(23) xor r_state_x(22) xor r_state_x(15) xor r_state_x(28) xor r_state_x( 6);
                r_state_x(27) <= r_state_x(30) xor r_state_x( 9) xor r_state_x(10) xor r_state_x(28) xor r_state_x(18) xor r_state_x(15);
                r_state_x(28) <= r_state_x(25) xor r_state_x(20) xor r_state_x(19) xor r_state_x(12) xor r_state_x(28);
                r_state_x(29) <= r_state_x(13) xor r_state_x(10) xor r_state_x( 9) xor r_state_x( 8) xor r_state_x( 0) xor r_state_x(14);
                r_state_x(30) <= r_state_x(22) xor r_state_x(27) xor r_state_x( 3) xor r_state_x(13) xor r_state_x(23);
                r_state_x(31) <= r_state_x(12) xor r_state_x( 2) xor r_state_x(16) xor r_state_x( 1) xor r_state_x(17) xor r_state_x(23);
                
                for i in 0 to streams - 1 loop
                    v_mixin := r_state_x xor salts(i);
                    v_mixup := r_state_y(32 * ((i + 1) mod streams) + 31 downto 32 * ((i + 1) mod streams));
                    v_res( 0) := v_mixup( 0) xor (v_mixup( 6) and not v_mixup(16)) xor v_mixup( 9) xor v_mixup(15) xor v_mixin((i + 15) mod 32);
                    v_res( 1) := v_mixup( 1) xor (v_mixup( 7) and not v_mixup(17)) xor v_mixup(10) xor v_mixup(16) xor v_mixin((i + 29) mod 32);
                    v_res( 2) := v_mixup( 2) xor (v_mixup( 8) and not v_mixup(18)) xor v_mixup(11) xor v_mixup(17) xor v_mixin((i +  5) mod 32);
                    v_res( 3) := v_mixup( 3) xor (v_mixup( 9) and not v_mixup(19)) xor v_mixup(12) xor v_mixup(18) xor v_mixin((i +  0) mod 32);
                    v_res( 4) := v_mixup( 4) xor (v_mixup(10) and not v_mixup(20)) xor v_mixup(13) xor v_mixup(19) xor v_mixin((i + 16) mod 32);
                    v_res( 5) := v_mixup( 5) xor (v_mixup(11) and not v_mixup(21)) xor v_mixup(14) xor v_mixup(20) xor v_mixin((i +  9) mod 32);
                    v_res( 6) := v_mixup( 6) xor (v_mixup(12) and not v_mixup(22)) xor v_mixup(15) xor v_mixup(21) xor v_mixin((i + 26) mod 32);
                    v_res( 7) := v_mixup( 7) xor (v_mixup(13) and not v_mixup(23)) xor v_mixup(16) xor v_mixup(22) xor v_mixin((i + 14) mod 32);
                    v_res( 8) := v_mixup( 8) xor (v_mixup(14) and not v_mixup(24)) xor v_mixup(17) xor v_mixup(23) xor v_mixin((i + 13) mod 32);
                    v_res( 9) := v_mixup( 9) xor (v_mixup(15) and not v_mixup(25)) xor v_mixup(18) xor v_mixup(24) xor v_mixin((i + 10) mod 32);
                    v_res(10) := v_mixup(10) xor (v_mixup(16) and not v_mixup(26)) xor v_mixup(19) xor v_mixup(25) xor v_mixin((i + 19) mod 32);
                    v_res(11) := v_mixup(11) xor (v_mixup(17) and not v_mixup(27)) xor v_mixup(20) xor v_mixup(26) xor v_mixin((i + 11) mod 32);
                    v_res(12) := v_mixup(12) xor (v_mixup(18) and not v_mixup(28)) xor v_mixup(21) xor v_mixup(27) xor v_mixin((i +  2) mod 32);
                    v_res(13) := v_mixup(13) xor (v_mixup(19) and not v_mixup(29)) xor v_mixup(22) xor v_mixup(28) xor v_mixin((i +  6) mod 32);
                    v_res(14) := v_mixup(14) xor (v_mixup(20) and not v_mixup(30)) xor v_mixup(23) xor v_mixup(29) xor v_mixin((i +  8) mod 32);
                    v_res(15) := v_mixup(15) xor (v_mixup(21) and not v_mixup(31)) xor v_mixup(24) xor v_mixup(30) xor v_mixin((i + 17) mod 32);
                    v_state_y(32 * i + 31 downto 32 * i) := v_res & r_state_y(32 * i + 31 downto 32 * i + 16);
                end loop;
                
                for i in 0 to streams - 1 loop
                    v_mixin := r_state_x xor salts(i);
                    v_mixup := v_state_y(32 * ((i + 1) mod streams) + 31 downto 32 * ((i + 1) mod streams));
                    v_res( 0) := v_mixup( 0) xor (v_mixup( 6) and not v_mixup(16)) xor v_mixup( 9) xor v_mixup(15) xor v_mixin((i + 20) mod 32);
                    v_res( 1) := v_mixup( 1) xor (v_mixup( 7) and not v_mixup(17)) xor v_mixup(10) xor v_mixup(16) xor v_mixin((i +  4) mod 32);
                    v_res( 2) := v_mixup( 2) xor (v_mixup( 8) and not v_mixup(18)) xor v_mixup(11) xor v_mixup(17) xor v_mixin((i + 22) mod 32);
                    v_res( 3) := v_mixup( 3) xor (v_mixup( 9) and not v_mixup(19)) xor v_mixup(12) xor v_mixup(18) xor v_mixin((i + 30) mod 32);
                    v_res( 4) := v_mixup( 4) xor (v_mixup(10) and not v_mixup(20)) xor v_mixup(13) xor v_mixup(19) xor v_mixin((i + 31) mod 32);
                    v_res( 5) := v_mixup( 5) xor (v_mixup(11) and not v_mixup(21)) xor v_mixup(14) xor v_mixup(20) xor v_mixin((i + 21) mod 32);
                    v_res( 6) := v_mixup( 6) xor (v_mixup(12) and not v_mixup(22)) xor v_mixup(15) xor v_mixup(21) xor v_mixin((i + 24) mod 32);
                    v_res( 7) := v_mixup( 7) xor (v_mixup(13) and not v_mixup(23)) xor v_mixup(16) xor v_mixup(22) xor v_mixin((i + 25) mod 32);
                    v_res( 8) := v_mixup( 8) xor (v_mixup(14) and not v_mixup(24)) xor v_mixup(17) xor v_mixup(23) xor v_mixin((i + 18) mod 32);
                    v_res( 9) := v_mixup( 9) xor (v_mixup(15) and not v_mixup(25)) xor v_mixup(18) xor v_mixup(24) xor v_mixin((i + 27) mod 32);
                    v_res(10) := v_mixup(10) xor (v_mixup(16) and not v_mixup(26)) xor v_mixup(19) xor v_mixup(25) xor v_mixin((i + 28) mod 32);
                    v_res(11) := v_mixup(11) xor (v_mixup(17) and not v_mixup(27)) xor v_mixup(20) xor v_mixup(26) xor v_mixin((i + 23) mod 32);
                    v_res(12) := v_mixup(12) xor (v_mixup(18) and not v_mixup(28)) xor v_mixup(21) xor v_mixup(27) xor v_mixin((i + 12) mod 32);
                    v_res(13) := v_mixup(13) xor (v_mixup(19) and not v_mixup(29)) xor v_mixup(22) xor v_mixup(28) xor v_mixin((i +  7) mod 32);
                    v_res(14) := v_mixup(14) xor (v_mixup(20) and not v_mixup(30)) xor v_mixup(23) xor v_mixup(29) xor v_mixin((i +  1) mod 32);
                    v_res(15) := v_mixup(15) xor (v_mixup(21) and not v_mixup(31)) xor v_mixup(24) xor v_mixup(30) xor v_mixin((i +  3) mod 32);
                    r_state_y(32 * i + 31 downto 32 * i) <= v_res & v_state_y(32 * i + 31 downto 32 * i + 16);
                end loop;
                
            end if;
        end if;
    end process;
    
end rtl;

