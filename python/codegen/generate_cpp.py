# Copyright (c) 2020-2021 Maarten Baert <info@maartenbaert.be>
# Available under the MIT License - see LICENSE.txt for details.

import collections
import math
import numpy
import numpy.linalg
import random
import subprocess

from xormix_all import modules

factors = {}
for n in modules:
	p = subprocess.Popen(['factor', str(2**n - 1)], stdout=subprocess.PIPE)
	res = p.communicate()[0].decode().strip()
	allfactors = [int(x) for x in res.split()[1:]]
	factors[n] = list(collections.OrderedDict.fromkeys(allfactors))

def write_array(f, name, n, words, cols, braces=False, dec=False):
	limbs = (n + 63) // 64
	nl = n // limbs
	nt = 1 << (nl - 1).bit_length()
	ml = (1 << nl) - 1
	chars = nl // 4
	values = []
	for word in words:
		values2 = []
		for limb in range(limbs):
			value = (word >> (limb * nl)) & ml
			values2.append(f'UINT{nt}_C(0x{value:0{chars}x})')
		values.append(('{' if braces else '') + ', '.join(values2) + ('}' if braces else ''))
	f.write(name + ' = {\n')
	for i in range(0, len(values), cols // limbs):
		f.write('\t' + ', '.join(values[i : i + cols // limbs]) + ',\n')
	f.write('};\n')

def write_array_dec(f, name, n, words, cols):
	chars = int(math.log10(n)) + 1
	values = []
	for word in words:
		values.append(f'{word:{chars}d}')
	f.write(name + ' = {\n')
	for i in range(0, len(values), cols):
		f.write('\t' + ', '.join(values[i : i + cols]) + ',\n')
	f.write('};\n')

def generate_xormix(filename):
	with open(filename, 'w') as f:
		f.write(f'// Copyright (c) 2020-2021 Maarten Baert <info@maartenbaert.be>\n')
		f.write(f'// Available under the MIT License - see LICENSE.txt for details.\n')
		f.write(f'\n')
		f.write(f'// This file was generated by `generate_cpp.py`.\n')
		f.write(f'\n')
		f.write(f'#include "xormix.hpp"\n')
		for n in modules:
			periods = [(2**n - 1) // x for x in factors[n]]
			f.write(f'\n')
			f.write(f'template<>\n')
			f.write(f'const size_t xormix{n}::REVISION = {modules[n].revision};\n')
		for n in modules:
			periods = [(2**n - 1) // x for x in factors[n]]
			f.write(f'\n')
			f.write(f'template<>\n')
			write_array(f, f'const std::initializer_list<xormix{n}::word_t> xormix{n}::TEST_PERIODS', n, periods, 2, braces=True)
		for n in modules:
			xortable = numpy.zeros(n, dtype=object)
			for i in range(n):
				for j in modules[n].matrix[i]:
					xortable[j] |= 1 << i
			limbs = (n + 63) // 64
			xormatrix = xortable.reshape((limbs, -1)).flatten('F')
			f.write(f'\n')
			f.write(f'template<>\n')
			write_array(f, f'const xormix{n}::matrix_t xormix{n}::XORMIX_MATRIX', n, xormatrix, 4)
		for n in modules:
			m = numpy.zeros((n, n), dtype=numpy.uint8)
			for i in range(n):
				for j in modules[n].matrix[i]:
					m[i, j] = 1
			minv = numpy.linalg.matrix_power(m, 2**n - 2) & 1
			xortable = numpy.zeros(n, dtype=object)
			for i in range(n):
				for j in range(n):
					xortable[j] |= int(minv[i, j]) << i
			limbs = (n + 63) // 64
			xormatrix = xortable.reshape((limbs, -1)).flatten('F')
			f.write(f'\n')
			f.write(f'template<>\n')
			write_array(f, f'const xormix{n}::matrix_t xormix{n}::XORMIX_MATRIX_INV', n, xormatrix, 4)
		for n in modules:
			shuffled_salts = []
			for s in range(n):
				salt = modules[n].salts[s]
				shuffled = 0
				for i in range(n):
					j = (s + modules[n].shuffle[i]) % n
					shuffled |= ((salt >> j) & 1) << i
				shuffled_salts.append(shuffled)
			f.write(f'\n')
			f.write(f'template<>\n')
			write_array(f, f'const xormix{n}::word_t xormix{n}::XORMIX_SALTS[{n}]', n, shuffled_salts, 4)
		for n in modules:
			f.write(f'\n')
			f.write(f'template<>\n')
			write_array_dec(f, f'const size_t xormix{n}::XORMIX_SHUFFLE[{n}]', n, modules[n].shuffle, 16)
		for n in modules:
			shifts = '{' + ', '.join(str(x) for x in modules[n].shifts) + '}'
			f.write(f'\n')
			f.write(f'template<>\n')
			f.write(f'const size_t xormix{n}::XORMIX_SHIFTS[4] = {shifts};\n')
		f.write(f'\n')
		f.write(f'template class xormix<uint16_t, 16, 1>;\n');
		f.write(f'template class xormix<uint32_t, 24, 1>;\n');
		f.write(f'template class xormix<uint32_t, 32, 1>;\n');
		f.write(f'template class xormix<uint64_t, 48, 1>;\n');
		f.write(f'template class xormix<uint64_t, 64, 1>;\n');
		f.write(f'template class xormix<uint64_t, 48, 2>;\n');
		f.write(f'template class xormix<uint64_t, 64, 2>;\n');

if __name__ == '__main__':
	generate_xormix(f'../../cpp/common/xormix.cpp')
