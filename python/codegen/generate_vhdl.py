# Copyright (c) 2020-2021 Maarten Baert <info@maartenbaert.be>
# Available under the MIT License - see LICENSE.txt for details.

import math
import random

from xormix_all import modules

random.seed(0x75cf32031077f039)

def generate_rtl(n, filename):
	l = math.ceil(math.log10(n))
	matrix = modules[n].matrix
	salts = modules[n].salts
	shuffle = modules[n].shuffle
	shifts = modules[n].shifts
	with open(filename, 'w') as f:
		f.write(f'-- Copyright (c) 2020-2021 Maarten Baert <info@maartenbaert.be>\n')
		f.write(f'-- Available under the MIT License - see LICENSE.txt for details.\n')
		f.write(f'\n')
		f.write(f'-- This file was generated by `generate_vhdl.py`.\n')
		f.write(f'-- Revision: {modules[n].revision}\n')
		f.write(f'\n')
		f.write(f'library ieee;\n')
		f.write(f'use ieee.std_logic_1164.all;\n')
		f.write(f'\n')
		f.write(f'entity xormix{n} is\n')
		f.write(f'    generic (\n')
		f.write(f'        streams : integer range 1 to {n} := 1\n')
		f.write(f'    );\n')
		f.write(f'    port (\n')
		f.write(f'        \n')
		f.write(f'        -- clock and synchronous reset\n')
		f.write(f'        clk    : in std_logic;\n')
		f.write(f'        rst    : in std_logic;\n')
		f.write(f'        \n')
		f.write(f'        -- configuration\n')
		f.write(f'        seed_x : in std_logic_vector({n - 1} downto 0);\n')
		f.write(f'        seed_y : in std_logic_vector({n} * streams - 1 downto 0);\n')
		f.write(f'        \n')
		f.write(f'        -- random number generator\n')
		f.write(f'        enable : in std_logic;\n')
		f.write(f'        result : out std_logic_vector({n} * streams - 1 downto 0)\n')
		f.write(f'        \n')
		f.write(f'    );\n')
		f.write(f'end xormix{n};\n')
		f.write(f'\n')
		f.write(f'architecture rtl of xormix{n} is\n')
		f.write(f'    \n')
		f.write(f'    type salts_t is array(0 to {n - 1}) of std_logic_vector({n - 1} downto 0);\n')
		f.write(f'    constant salts : salts_t := (\n')
		for i in range(0, n, 4):
			row = ', '.join(f'x"{x:0{n // 4}x}"' for x in salts[i : i + 4])
			f.write(f'        ' + row + ('\n' if i == n - 4 else ',\n'))
		f.write(f'    );\n')
		f.write(f'    \n')
		f.write(f'    signal r_state_x : std_logic_vector({n - 1} downto 0);\n')
		f.write(f'    signal r_state_y : std_logic_vector({n} * streams - 1 downto 0);\n')
		f.write(f'    \n')
		f.write(f'begin\n')
		f.write(f'    \n')
		f.write(f'    result <= r_state_y;\n')
		f.write(f'    \n')
		f.write(f'    process (clk)\n')
		f.write(f'        \n')
		f.write(f'        variable v_state_y : std_logic_vector({n} * streams - 1 downto 0);\n')
		f.write(f'        \n')
		f.write(f'        variable v_mixin : std_logic_vector({n - 1} downto 0);\n')
		f.write(f'        variable v_mixup : std_logic_vector({n - 1} downto 0);\n')
		f.write(f'        variable v_res : std_logic_vector({n // 2 - 1} downto 0);\n')
		f.write(f'        \n')
		f.write(f'    begin\n')
		f.write(f'        if rising_edge(clk) then\n')
		f.write(f'            if rst = \'1\' then\n')
		f.write(f'                \n')
		f.write(f'                r_state_x <= seed_x;\n')
		f.write(f'                r_state_y <= seed_y;\n')
		f.write(f'                \n')
		f.write(f'            elsif enable = \'1\' then\n')
		f.write(f'                \n')
		for i in range(n):
			row = ' xor '.join(f'r_state_x({j:{l}})' for j in matrix[i])
			f.write(f'                r_state_x({i:{l}}) <= {row};\n')
		f.write(f'                \n')
		f.write(f'                for i in 0 to streams - 1 loop\n')
		f.write(f'                    v_mixin := r_state_x xor salts(i);\n')
		f.write(f'                    v_mixup := r_state_y({n} * ((i + 1) mod streams) + {n - 1} downto {n} * ((i + 1) mod streams));\n')
		for k in range(n // 2):
			f.write(f'                    v_res({k:{l}}) := v_mixup({k:{l}}) xor (v_mixup({k + shifts[0]:{l}}) and not v_mixup({k + shifts[1]:{l}})) xor v_mixup({k + shifts[2]:{l}}) xor v_mixup({k + shifts[3]:{l}}) xor v_mixin((i + {shuffle[k]:{l}}) mod {n});\n')
		f.write(f'                    v_state_y({n} * i + {n - 1} downto {n} * i) := v_res & r_state_y({n} * i + {n - 1} downto {n} * i + {n // 2});\n')
		f.write(f'                end loop;\n')
		f.write(f'                \n')
		f.write(f'                for i in 0 to streams - 1 loop\n')
		f.write(f'                    v_mixin := r_state_x xor salts(i);\n')
		f.write(f'                    v_mixup := v_state_y({n} * ((i + 1) mod streams) + {n - 1} downto {n} * ((i + 1) mod streams));\n')
		for k in range(n // 2):
			f.write(f'                    v_res({k:{l}}) := v_mixup({k:{l}}) xor (v_mixup({k + shifts[0]:{l}}) and not v_mixup({k + shifts[1]:{l}})) xor v_mixup({k + shifts[2]:{l}}) xor v_mixup({k + shifts[3]:{l}}) xor v_mixin((i + {shuffle[k + n // 2]:{l}}) mod {n});\n')
		f.write(f'                    r_state_y({n} * i + {n - 1} downto {n} * i) <= v_res & v_state_y({n} * i + {n - 1} downto {n} * i + {n // 2});\n')
		f.write(f'                end loop;\n')
		f.write(f'                \n')
		f.write(f'            end if;\n')
		f.write(f'        end if;\n')
		f.write(f'    end process;\n')
		f.write(f'    \n')
		f.write(f'end rtl;\n')

def generate_tb(n, filename, modulename=None):
	if modulename is None:
		modulename = f'xormix{n}'
	test_streams = 4
	test_outputs = 100
	seed = [random.getrandbits(n) for i in range(test_streams + 1)]
	state = seed.copy()
	output = []
	for i in range(test_outputs):
		output.append(state[1 :])
		modules[n].next_state(state)
	l = math.ceil(math.log10(n))
	with open(filename, 'w') as f:
		f.write(f'-- Copyright (c) 2020-2021 Maarten Baert <info@maartenbaert.be>\n')
		f.write(f'-- Available under the MIT License - see LICENSE.txt for details.\n')
		f.write(f'\n')
		f.write(f'-- This file was generated by `generate_vhdl.py`.\n')
		f.write(f'\n')
		f.write(f'library ieee;\n')
		f.write(f'use ieee.std_logic_1164.all;\n')
		f.write(f'\n')
		f.write(f'entity xormix{n}_tb is\n')
		f.write(f'end xormix{n}_tb;\n')
		f.write(f'\n')
		f.write(f'architecture bhv of xormix{n}_tb is\n')
		f.write(f'    \n')
		f.write(f'    -- configuration\n')
		f.write(f'    constant streams : integer := {test_streams};\n')
		f.write(f'    constant results : integer := {test_outputs};\n')
		f.write(f'    constant seed_x  : std_logic_vector({n - 1} downto 0) :=\n')
		f.write(f'        x"{seed[0]:0{n // 4}x}";\n')
		f.write(f'    constant seed_y  : std_logic_vector({n} * streams - 1 downto 0) :=\n')
		row = ''.join(f'{s:0{n // 4}x}' for s in reversed(seed[1 :]))
		f.write(f'        x"{row}";\n')
		f.write(f'    \n')
		f.write(f'    -- reference result\n')
		f.write(f'    type result_array_t is array(0 to results - 1) of std_logic_vector({n} * streams - 1 downto 0);\n')
		f.write(f'    signal ref_result : result_array_t := (\n')
		for i in range(test_outputs):
			row = ''.join(f'{s:0{n // 4}x}' for s in reversed(output[i]))
			f.write(f'        x"{row}"' + ('\n' if i == test_outputs - 1 else ',\n'))
		f.write(f'    );\n')
		f.write(f'    \n')
		f.write(f'    -- DUT signals\n')
		f.write(f'    signal clk    : std_logic := \'0\';\n')
		f.write(f'    signal rst    : std_logic;\n')
		f.write(f'    signal enable : std_logic;\n')
		f.write(f'    signal result : std_logic_vector({n} * streams - 1 downto 0);\n')
		f.write(f'    \n')
		f.write(f'    -- flag to stop simulation\n')
		f.write(f'    signal run : boolean := true;\n')
		f.write(f'    \n')
		f.write(f'begin\n')
		f.write(f'    \n')
		f.write(f'    -- DUT\n')
		f.write(f'    inst_xormix : entity work.{modulename} generic map(\n')
		f.write(f'        streams => streams\n')
		f.write(f'    ) port map (\n')
		f.write(f'        clk    => clk,\n')
		f.write(f'        rst    => rst,\n')
		f.write(f'        seed_x => seed_x,\n')
		f.write(f'        seed_y => seed_y,\n')
		f.write(f'        enable => enable,\n')
		f.write(f'        result => result\n')
		f.write(f'    );\n')
		f.write(f'    \n')
		f.write(f'    -- clock process\n')
		f.write(f'    process\n')
		f.write(f'    begin\n')
		f.write(f'        while run loop\n')
		f.write(f'            clk <= \'1\';\n')
		f.write(f'            wait for 5 ns;\n')
		f.write(f'            clk <= \'0\';\n')
		f.write(f'            wait for 5 ns;\n')
		f.write(f'        end loop;\n')
		f.write(f'        wait;\n')
		f.write(f'    end process;\n')
		f.write(f'    \n')
		f.write(f'    -- input/output process\n')
		f.write(f'    process\n')
		f.write(f'        variable errors : natural := 0;\n')
		f.write(f'    begin\n')
		f.write(f'        wait until rising_edge(clk);\n')
		f.write(f'        rst <= \'1\';\n')
		f.write(f'        enable <= \'0\';\n')
		f.write(f'        wait until rising_edge(clk);\n')
		f.write(f'        rst <= \'0\';\n')
		f.write(f'        enable <= \'1\';\n')
		f.write(f'        for i in 0 to results - 1 loop\n')
		f.write(f'            wait until rising_edge(clk);\n')
		f.write(f'            if result /= ref_result(i) then\n')
		f.write(f'                report "Incorrect result for i=" & integer\'image(i) severity warning;\n')
		f.write(f'                errors := errors + 1;\n')
		f.write(f'            end if;\n')
		f.write(f'        end loop;\n')
		f.write(f'        report "Test complete, number of errors: " & integer\'image(errors) severity note;\n')
		f.write(f'        run <= false;\n')
		f.write(f'        wait;\n')
		f.write(f'    end process;\n')
		f.write(f'    \n')
		f.write(f'end bhv;\n')

if __name__ == '__main__':

	for n in modules:
		generate_rtl(n, f'../../vhdl/rtl/xormix{n}.vhd')

	for n in modules:
		generate_tb(n, f'../../vhdl/tb/xormix{n}_tb.vhd')
