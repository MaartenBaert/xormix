# Copyright (c) 2020-2021 Maarten Baert <info@maartenbaert.be>
# Available under the MIT License - see LICENSE.txt for details.

import math

from xormix_all import modules
import generate_vhdl

def lut_value(func, n):
	val = 0
	for i in range(2**n):
		val |= func(*[(i >> j) & 1 for j in range(n)]) << i
	return val

def lut_inst(name, output, inputs, value):
	digits = (2**len(inputs) + 3) // 4
	inputs_str = ', '.join(f'I{i} => {v}' for (i, v) in enumerate(inputs))
	return f'{name}: LUT{len(inputs)} generic map (INIT => X"{value:0{digits}x}") port map (O => {output}, {inputs_str});\n'

def generate_rtl_x7s(n, filename):
	l = math.ceil(math.log10(n))
	matrix = modules[n].matrix
	salts = modules[n].salts
	shuffle = modules[n].shuffle
	shifts = modules[n].shifts
	lut_xor = {
		5: lut_value(lambda a, b, c, d, e: a ^ b ^ c ^ d ^ e, 5),
		6: lut_value(lambda a, b, c, d, e, f: a ^ b ^ c ^ d ^ e ^ f, 6),
	}
	lut_mix = {
		0: lut_value(lambda a, b, c, d, e, f: a ^ (b & (c ^ 1)) ^ d ^ e ^ f ^ 0, 6),
		1: lut_value(lambda a, b, c, d, e, f: a ^ (b & (c ^ 1)) ^ d ^ e ^ f ^ 1, 6),
	}
	with open(filename, 'w') as f:
		f.write(f'-- Copyright (c) 2020-2021 Maarten Baert <info@maartenbaert.be>\n')
		f.write(f'-- Available under the MIT License - see LICENSE.txt for details.\n')
		f.write(f'\n')
		f.write(f'-- This file was generated by `generate_vhdl_x7s.py`.\n')
		f.write(f'-- This is a non-portable implementation optimized for Xilinx 7-Series FPGAs.\n')
		f.write(f'-- Revision: {modules[n].revision}\n')
		f.write(f'\n')
		f.write(f'library ieee;\n')
		f.write(f'use ieee.std_logic_1164.all;\n')
		f.write(f'\n')
		f.write(f'library unisim;\n')
		f.write(f'use unisim.vcomponents.all;\n')
		f.write(f'\n')
		f.write(f'entity xormix{n}_x7s is\n')
		f.write(f'    generic (\n')
		f.write(f'        streams : integer range 1 to {n} := 1\n')
		f.write(f'    );\n')
		f.write(f'    port (\n')
		f.write(f'        \n')
		f.write(f'        -- clock and synchronous reset\n')
		f.write(f'        clk    : in std_logic;\n')
		f.write(f'        rst    : in std_logic;\n')
		f.write(f'        \n')
		f.write(f'        -- configuration\n')
		f.write(f'        seed_x : in std_logic_vector({n - 1} downto 0);\n')
		f.write(f'        seed_y : in std_logic_vector({n} * streams - 1 downto 0);\n')
		f.write(f'        \n')
		f.write(f'        -- random number generator\n')
		f.write(f'        enable : in std_logic;\n')
		f.write(f'        result : out std_logic_vector({n} * streams - 1 downto 0)\n')
		f.write(f'        \n')
		f.write(f'    );\n')
		f.write(f'end xormix{n}_x7s;\n')
		f.write(f'\n')
		f.write(f'architecture rtl of xormix{n}_x7s is\n')
		f.write(f'    \n')
		f.write(f'    constant lutval_xor5 : bit_vector(31 downto 0) := x"{lut_xor[5]:08x}";\n')
		f.write(f'    constant lutval_xor6 : bit_vector(63 downto 0) := x"{lut_xor[6]:016x}";\n')
		f.write(f'    constant lutval_mix0 : bit_vector(63 downto 0) := x"{lut_mix[0]:016x}";\n')
		f.write(f'    constant lutval_mix1 : bit_vector(63 downto 0) := x"{lut_mix[1]:016x}";\n')
		f.write(f'    \n')
		f.write(f'    function select_lutval_mix(\n')
		f.write(f'        bit : std_logic\n')
		f.write(f'    ) return bit_vector is\n')
		f.write(f'    begin\n')
		f.write(f'        if bit = \'0\' then\n')
		f.write(f'            return lutval_mix0;\n')
		f.write(f'        else\n')
		f.write(f'            return lutval_mix1;\n')
		f.write(f'        end if;\n')
		f.write(f'    end select_lutval_mix;\n')
		f.write(f'    \n')
		f.write(f'    type matrix_t is array(0 to {n // 2 - 1}, 0 to 10) of integer range 0 to {n - 1};\n')
		f.write(f'    constant matrix : matrix_t := (\n')
		for i in range(n // 2):
			row = ', '.join(f'{x:{l}}' for x in matrix[2 * i] + matrix[2 * i + 1])
			f.write(f'        (' + row + (')\n' if i == n // 2 - 1 else '),\n'))
		f.write(f'    );\n')
		f.write(f'    \n')
		f.write(f'    type salts_t is array(0 to {n - 1}) of std_logic_vector({n - 1} downto 0);\n')
		f.write(f'    constant salts : salts_t := (\n')
		for i in range(0, n, 4):
			row = ', '.join(f'x"{x:0{n // 4}x}"' for x in salts[i : i + 4])
			f.write(f'        ' + row + ('\n' if i == n - 4 else ',\n'))
		f.write(f'    );\n')
		f.write(f'    \n')
		f.write(f'    type shuffle_t is array(0 to {n - 1}) of integer range 0 to {n - 1};\n')
		f.write(f'    constant shuffle : shuffle_t := (\n')
		for i in range(0, n, 8):
			row = ', '.join(f'{x:{l}}' for x in shuffle[i : i + 8])
			f.write(f'        ' + row + ('\n' if i == n - 8 else ',\n'))
		f.write(f'    );\n')
		f.write(f'    \n')
		f.write(f'    signal r_state_x : std_logic_vector({n - 1} downto 0);\n')
		f.write(f'    signal r_state_y : std_logic_vector({n} * streams - 1 downto 0);\n')
		f.write(f'    \n')
		f.write(f'    signal state_x_next : std_logic_vector({n - 1} downto 0);\n')
		f.write(f'    signal state_y_next : std_logic_vector({n} * streams - 1 downto 0);\n')
		f.write(f'    \n')
		f.write(f'    type state_sr_t is array(0 to streams - 1) of std_logic_vector({2 * n - 1} downto 0);\n')
		f.write(f'    signal state_sr : state_sr_t;\n')
		f.write(f'    \n')
		f.write(f'begin\n')
		f.write(f'    \n')
		f.write(f'    result <= r_state_y;\n')
		f.write(f'    \n')
		f.write(f'    gen_bits: for i in 0 to {n // 2 - 1} generate\n')
		f.write(f'        lut_xor5: LUT5 generic map (\n')
		f.write(f'            INIT => lutval_xor5\n')
		f.write(f'        ) port map (\n')
		f.write(f'            O => state_x_next(2 * i),\n')
		f.write(f'            I0 => r_state_x(matrix(i, 0)),\n')
		f.write(f'            I1 => r_state_x(matrix(i, 1)),\n')
		f.write(f'            I2 => r_state_x(matrix(i, 2)),\n')
		f.write(f'            I3 => r_state_x(matrix(i, 3)),\n')
		f.write(f'            I4 => r_state_x(matrix(i, 4))\n')
		f.write(f'        );\n')
		f.write(f'        lut_xor6: LUT6 generic map (\n')
		f.write(f'            INIT => lutval_xor6\n')
		f.write(f'        ) port map (\n')
		f.write(f'            O => state_x_next(2 * i + 1),\n')
		f.write(f'            I0 => r_state_x(matrix(i, 5)),\n')
		f.write(f'            I1 => r_state_x(matrix(i, 6)),\n')
		f.write(f'            I2 => r_state_x(matrix(i, 7)),\n')
		f.write(f'            I3 => r_state_x(matrix(i, 8)),\n')
		f.write(f'            I4 => r_state_x(matrix(i, 9)),\n')
		f.write(f'            I5 => r_state_x(matrix(i, 10))\n')
		f.write(f'        );\n')
		f.write(f'    end generate;\n')
		f.write(f'    \n')
		f.write(f'    gen_stream: for i in 0 to streams - 1 generate\n')
		f.write(f'        constant k : integer := (i + 1) mod streams;\n')
		f.write(f'    begin\n')
		f.write(f'        state_sr(i)({n - 1} downto 0) <= r_state_y({n} * i + {n - 1} downto {n} * i);\n')
		f.write(f'        gen_bit: for j in 0 to {n - 1} generate\n')
		f.write(f'            constant l : integer := (i + shuffle(j)) mod {n};\n')
		f.write(f'        begin\n')
		f.write(f'            lut_mix: LUT6 generic map (\n')
		f.write(f'                INIT => select_lutval_mix(salts(i)(l))\n')
		f.write(f'            ) port map (\n')
		f.write(f'                O => state_sr(i)(j + {n}),\n')
		f.write(f'                I0 => state_sr(k)(j),\n')
		f.write(f'                I1 => state_sr(k)(j + {shifts[0]}),\n')
		f.write(f'                I2 => state_sr(k)(j + {shifts[1]}),\n')
		f.write(f'                I3 => state_sr(k)(j + {shifts[2]}),\n')
		f.write(f'                I4 => state_sr(k)(j + {shifts[3]}),\n')
		f.write(f'                I5 => r_state_x(l)\n')
		f.write(f'            );\n')
		f.write(f'        end generate;\n')
		f.write(f'        state_y_next({n} * i + {n - 1} downto {n} * i) <= state_sr(i)({2 * n - 1} downto {n});\n')
		f.write(f'    end generate;\n')
		f.write(f'    \n')
		f.write(f'    process (clk)\n')
		f.write(f'    begin\n')
		f.write(f'        if rising_edge(clk) then\n')
		f.write(f'            if rst = \'1\' then\n')
		f.write(f'                r_state_x <= seed_x;\n')
		f.write(f'                r_state_y <= seed_y;\n')
		f.write(f'            elsif enable = \'1\' then\n')
		f.write(f'                r_state_x <= state_x_next;\n')
		f.write(f'                r_state_y <= state_y_next;\n')
		f.write(f'            end if;\n')
		f.write(f'        end if;\n')
		f.write(f'    end process;\n')
		f.write(f'    \n')
		f.write(f'end rtl;\n')

if __name__ == "__main__":

	for n in modules:
		generate_rtl_x7s(n, f'../../vhdl_x7s/rtl/xormix{n}_x7s.vhd')

	for n in modules:
		generate_vhdl.generate_tb(n, f'../../vhdl_x7s/tb/xormix{n}_tb.vhd', modulename=f'xormix{n}_x7s')
