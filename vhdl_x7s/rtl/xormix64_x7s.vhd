-- Copyright (c) 2020-2021 Maarten Baert <info@maartenbaert.be>
-- Available under the MIT License - see LICENSE.txt for details.

-- This file was generated by `generate_vhdl_x7s.py`.
-- This is a non-portable implementation optimized for Xilinx 7-Series FPGAs.
-- Revision: 1

library ieee;
use ieee.std_logic_1164.all;

library unisim;
use unisim.vcomponents.all;

entity xormix64_x7s is
    generic (
        streams : integer range 1 to 64 := 1
    );
    port (
        
        -- clock and synchronous reset
        clk    : in std_logic;
        rst    : in std_logic;
        
        -- configuration
        seed_x : in std_logic_vector(63 downto 0);
        seed_y : in std_logic_vector(64 * streams - 1 downto 0);
        
        -- random number generator
        enable : in std_logic;
        result : out std_logic_vector(64 * streams - 1 downto 0)
        
    );
end xormix64_x7s;

architecture rtl of xormix64_x7s is
    
    constant lutval_xor5 : bit_vector(31 downto 0) := x"96696996";
    constant lutval_xor6 : bit_vector(63 downto 0) := x"6996966996696996";
    constant lutval_mix0 : bit_vector(63 downto 0) := x"59a6a659a65959a6";
    constant lutval_mix1 : bit_vector(63 downto 0) := x"a65959a659a6a659";
    
    function select_lutval_mix(
        bit : std_logic
    ) return bit_vector is
    begin
        if bit = '0' then
            return lutval_mix0;
        else
            return lutval_mix1;
        end if;
    end select_lutval_mix;
    
    type matrix_t is array(0 to 31, 0 to 10) of integer range 0 to 63;
    constant matrix : matrix_t := (
        (56, 40, 59,  0, 27, 49, 48,  4, 39, 10, 31),
        (15, 35, 32,  7, 23, 14,  3, 37, 49, 28, 61),
        (48, 18, 59, 29, 25,  1, 44, 18, 19,  6,  2),
        (41, 39, 15, 14, 33, 59, 40, 32, 27, 63, 50),
        (10, 37, 17,  8, 21, 47, 30, 11, 25, 16, 58),
        (36, 60, 58, 23, 25, 47, 21, 46,  5, 29, 32),
        ( 7, 63, 44, 19, 60, 22, 52, 49, 18, 15,  3),
        (32, 46,  5,  6, 31, 42, 33, 16,  1, 21,  6),
        (34, 11, 18, 55, 12, 41, 43, 10, 47, 57, 28),
        (31, 38, 13, 32, 48,  8,  9, 36, 62,  1, 42),
        (45,  3, 57,  4, 59, 34, 27, 48, 39, 41, 12),
        (40, 17, 36, 54, 62, 13,  9, 45, 25, 28, 42),
        (21, 17, 54, 60,  0,  8, 48, 47, 40,  4, 19),
        (22, 25, 42, 37, 32,  6, 38, 26, 50, 49, 41),
        (26, 51, 62, 24, 15, 31,  6, 54, 56, 58, 29),
        (20, 63,  2, 22,  9,  5, 14, 42, 56, 12, 15),
        ( 8, 20, 51, 12, 53, 52, 43,  0, 11, 46, 23),
        (12, 20, 38, 16, 44, 28,  3, 59, 53, 38, 21),
        (10, 56, 30, 57, 38, 47, 50,  6, 54,  4, 49),
        (22, 36,  7, 45, 37, 46, 21, 26, 55, 58, 35),
        (14, 26, 34, 33, 17, 43, 50, 55, 58,  2,  1),
        (55, 57, 33, 49, 51, 47, 26, 22,  0, 35, 10),
        (30, 39, 56, 57,  7, 53, 24, 52, 12, 44, 36),
        ( 5, 58, 52,  9, 20,  7, 16, 62, 42, 53, 38),
        (19, 28,  4, 27, 13, 26, 46, 20, 27, 17, 29),
        (28, 40, 14,  4, 63,  2, 24, 61,  1,  5, 56),
        (45, 23, 44, 18, 39, 45, 40, 29, 61,  0, 33),
        ( 7, 50,  5, 62, 13, 13, 14, 61, 17, 63, 18),
        (27, 34,  9, 24, 11,  0, 19, 23,  7, 59, 25),
        (51,  4, 30, 46, 61, 11, 54, 52, 24, 60, 35),
        (30, 55, 53, 16, 31,  3, 33, 36, 58,  8, 45),
        (37, 41, 62, 34, 35, 63, 39, 22, 55, 43, 42)
    );
    
    type salts_t is array(0 to 63) of std_logic_vector(63 downto 0);
    constant salts : salts_t := (
        x"6c1f4cf86b670928", x"254b7cacdf1f7f73", x"9384f7a0b1b8600e", x"6402b3d837dfb664",
        x"7cb8aabfdc88b651", x"b89b5f5e1de22367", x"5def7160d6d4e4b9", x"8d2ef95b68e2110b",
        x"ffc0742fc5f3dbe3", x"87ce80324751b6e0", x"147610fcd384ae2a", x"bb625e1c429581e7",
        x"42c3fc05de25f0c0", x"db6752d26b3e7d9a", x"3edd68a5eb6ba2b1", x"63600f8ae4c7a36a",
        x"a8b436b35f0594b6", x"e7740ee396e0303c", x"4711b906c747cf69", x"2bd0973542881c68",
        x"9819f173380f1778", x"05fa834a446f5780", x"3aca5c28507a9812", x"3f8fae1df7b5284f",
        x"0fca61766c25a956", x"344a280b81b3dc59", x"9ae49767ed2aac9d", x"136354a988e7dc44",
        x"a47463136a589763", x"cca5d6d4ad8ff5e6", x"3e2a049598688d41", x"d79394eb53e8e614",
        x"3bebfb323f75041e", x"635aa20bf255c061", x"6026a67855446ab6", x"6f801ac1a01937d3",
        x"282dcf755931c792", x"42a866fb536b5c24", x"fc666ffe8b3ee689", x"a2e9693598d4d120",
        x"68d7594964f92460", x"adbcae73ac34dd49", x"993e260d3c6f44bc", x"5c72e28f77c7ab3d",
        x"6863f70a8cc13391", x"b3bc2c1931d5afe6", x"590494397519cd48", x"77ecc3481691cd65",
        x"1388ee338164ea29", x"2ff27333a309bbbc", x"eaebc14b790da4b9", x"61c2af10615a09fb",
        x"a35d4d739948bace", x"dda19468d60247e6", x"cf1f611a8269bc91", x"0adeb7af980adf73",
        x"14eccb6a88a0129e", x"71aaacdba83328de", x"135e1971c5db62b7", x"c5041c150065d8fd",
        x"42a68068988aff0c", x"f811709d805968db", x"e3bd59c3b7844bc4", x"e9602cb6280a6c70"
    );
    
    type shuffle_t is array(0 to 63) of integer range 0 to 63;
    constant shuffle : shuffle_t := (
        39, 11, 51, 53, 61, 31, 29, 27,
        12, 57, 43, 56, 42,  2, 26, 37,
        41, 10, 20, 44,  7, 28, 13,  9,
        25, 32, 52, 14, 19, 60, 48, 49,
         5, 36,  0,  3, 58, 22, 35, 21,
        16, 30, 34, 63,  8, 17, 24, 54,
        18, 50, 45,  6, 46, 33, 23, 62,
        15, 59, 55, 38, 40,  1,  4, 47
    );
    
    signal r_state_x : std_logic_vector(63 downto 0);
    signal r_state_y : std_logic_vector(64 * streams - 1 downto 0);
    
    signal state_x_next : std_logic_vector(63 downto 0);
    signal state_y_next : std_logic_vector(64 * streams - 1 downto 0);
    
    type state_sr_t is array(0 to streams - 1) of std_logic_vector(127 downto 0);
    signal state_sr : state_sr_t;
    
begin
    
    result <= r_state_y;
    
    gen_bits: for i in 0 to 31 generate
        lut_xor5: LUT5 generic map (
            INIT => lutval_xor5
        ) port map (
            O => state_x_next(2 * i),
            I0 => r_state_x(matrix(i, 0)),
            I1 => r_state_x(matrix(i, 1)),
            I2 => r_state_x(matrix(i, 2)),
            I3 => r_state_x(matrix(i, 3)),
            I4 => r_state_x(matrix(i, 4))
        );
        lut_xor6: LUT6 generic map (
            INIT => lutval_xor6
        ) port map (
            O => state_x_next(2 * i + 1),
            I0 => r_state_x(matrix(i, 5)),
            I1 => r_state_x(matrix(i, 6)),
            I2 => r_state_x(matrix(i, 7)),
            I3 => r_state_x(matrix(i, 8)),
            I4 => r_state_x(matrix(i, 9)),
            I5 => r_state_x(matrix(i, 10))
        );
    end generate;
    
    gen_stream: for i in 0 to streams - 1 generate
        constant k : integer := (i + 1) mod streams;
    begin
        state_sr(i)(63 downto 0) <= r_state_y(64 * i + 63 downto 64 * i);
        gen_bit: for j in 0 to 63 generate
            constant l : integer := (i + shuffle(j)) mod 64;
        begin
            lut_mix: LUT6 generic map (
                INIT => select_lutval_mix(salts(i)(l))
            ) port map (
                O => state_sr(i)(j + 64),
                I0 => state_sr(k)(j),
                I1 => state_sr(k)(j + 28),
                I2 => state_sr(k)(j + 31),
                I3 => state_sr(k)(j + 24),
                I4 => state_sr(k)(j + 30),
                I5 => r_state_x(l)
            );
        end generate;
        state_y_next(64 * i + 63 downto 64 * i) <= state_sr(i)(127 downto 64);
    end generate;
    
    process (clk)
    begin
        if rising_edge(clk) then
            if rst = '1' then
                r_state_x <= seed_x;
                r_state_y <= seed_y;
            elsif enable = '1' then
                r_state_x <= state_x_next;
                r_state_y <= state_y_next;
            end if;
        end if;
    end process;
    
end rtl;
