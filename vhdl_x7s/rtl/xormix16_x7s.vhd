-- Copyright (c) 2020-2021 Maarten Baert <info@maartenbaert.be>
-- Available under the MIT License - see LICENSE.txt for details.

-- This file was generated by `generate_vhdl_x7s.py`.
-- This is a non-portable implementation optimized for Xilinx 7-Series FPGAs.
-- Revision: 1

library ieee;
use ieee.std_logic_1164.all;

library unisim;
use unisim.vcomponents.all;

entity xormix16_x7s is
    generic (
        streams : integer range 1 to 16 := 1
    );
    port (
        
        -- clock and synchronous reset
        clk    : in std_logic;
        rst    : in std_logic;
        
        -- configuration
        seed_x : in std_logic_vector(15 downto 0);
        seed_y : in std_logic_vector(16 * streams - 1 downto 0);
        
        -- random number generator
        enable : in std_logic;
        result : out std_logic_vector(16 * streams - 1 downto 0)
        
    );
end xormix16_x7s;

architecture rtl of xormix16_x7s is
    
    constant lutval_xor5 : bit_vector(31 downto 0) := x"96696996";
    constant lutval_xor6 : bit_vector(63 downto 0) := x"6996966996696996";
    constant lutval_mix0 : bit_vector(63 downto 0) := x"59a6a659a65959a6";
    constant lutval_mix1 : bit_vector(63 downto 0) := x"a65959a659a6a659";
    
    function select_lutval_mix(
        bit : std_logic
    ) return bit_vector is
    begin
        if bit = '0' then
            return lutval_mix0;
        else
            return lutval_mix1;
        end if;
    end select_lutval_mix;
    
    type matrix_t is array(0 to 7, 0 to 10) of integer range 0 to 15;
    constant matrix : matrix_t := (
        ( 3, 11,  1,  4, 13, 11, 12, 10,  2,  8,  9),
        ( 0, 10, 11,  4, 15,  1, 11, 13,  0,  6, 10),
        ( 8,  3,  6,  1,  7,  3,  5,  4,  1, 14,  6),
        ( 8,  7, 12, 11, 13, 14,  7,  8,  5, 13, 10),
        ( 7,  0,  4, 12, 13, 15,  3,  9,  2, 11,  5),
        ( 0,  9,  6, 11,  4, 12, 15,  2,  3, 14,  0),
        (14,  3,  9, 13,  0,  6, 10, 12,  7,  2,  1),
        ( 5,  7,  1, 15,  6,  0,  7, 10, 14,  9,  1)
    );
    
    type salts_t is array(0 to 15) of std_logic_vector(15 downto 0);
    constant salts : salts_t := (
        x"d2ba", x"bc36", x"16a6", x"e3eb",
        x"b749", x"5bc4", x"09f7", x"f491",
        x"5e28", x"2d5a", x"da5d", x"2cab",
        x"4058", x"7547", x"e94c", x"0a05"
    );
    
    type shuffle_t is array(0 to 15) of integer range 0 to 15;
    constant shuffle : shuffle_t := (
         4,  5, 14,  2,  9,  7,  3,  0,
        10,  6, 13,  8, 11, 15,  1, 12
    );
    
    signal r_state_x : std_logic_vector(15 downto 0);
    signal r_state_y : std_logic_vector(16 * streams - 1 downto 0);
    
    signal state_x_next : std_logic_vector(15 downto 0);
    signal state_y_next : std_logic_vector(16 * streams - 1 downto 0);
    
    type state_sr_t is array(0 to streams - 1) of std_logic_vector(31 downto 0);
    signal state_sr : state_sr_t;
    
begin
    
    result <= r_state_y;
    
    gen_bits: for i in 0 to 7 generate
        lut_xor5: LUT5 generic map (
            INIT => lutval_xor5
        ) port map (
            O => state_x_next(2 * i),
            I0 => r_state_x(matrix(i, 0)),
            I1 => r_state_x(matrix(i, 1)),
            I2 => r_state_x(matrix(i, 2)),
            I3 => r_state_x(matrix(i, 3)),
            I4 => r_state_x(matrix(i, 4))
        );
        lut_xor6: LUT6 generic map (
            INIT => lutval_xor6
        ) port map (
            O => state_x_next(2 * i + 1),
            I0 => r_state_x(matrix(i, 5)),
            I1 => r_state_x(matrix(i, 6)),
            I2 => r_state_x(matrix(i, 7)),
            I3 => r_state_x(matrix(i, 8)),
            I4 => r_state_x(matrix(i, 9)),
            I5 => r_state_x(matrix(i, 10))
        );
    end generate;
    
    gen_stream: for i in 0 to streams - 1 generate
        constant k : integer := (i + 1) mod streams;
    begin
        state_sr(i)(15 downto 0) <= r_state_y(16 * i + 15 downto 16 * i);
        gen_bit: for j in 0 to 15 generate
            constant l : integer := (i + shuffle(j)) mod 16;
        begin
            lut_mix: LUT6 generic map (
                INIT => select_lutval_mix(salts(i)(l))
            ) port map (
                O => state_sr(i)(j + 16),
                I0 => state_sr(k)(j),
                I1 => state_sr(k)(j + 4),
                I2 => state_sr(k)(j + 8),
                I3 => state_sr(k)(j + 5),
                I4 => state_sr(k)(j + 7),
                I5 => r_state_x(l)
            );
        end generate;
        state_y_next(16 * i + 15 downto 16 * i) <= state_sr(i)(31 downto 16);
    end generate;
    
    process (clk)
    begin
        if rising_edge(clk) then
            if rst = '1' then
                r_state_x <= seed_x;
                r_state_y <= seed_y;
            elsif enable = '1' then
                r_state_x <= state_x_next;
                r_state_y <= state_y_next;
            end if;
        end if;
    end process;
    
end rtl;
