-- Copyright (c) 2020-2021 Maarten Baert <info@maartenbaert.be>
-- Available under the MIT License - see LICENSE.txt for details.

-- This file was generated by `generate_vhdl_x7s.py`.
-- This is a non-portable implementation optimized for Xilinx 7-Series FPGAs.
-- Revision: 1

library ieee;
use ieee.std_logic_1164.all;

library unisim;
use unisim.vcomponents.all;

entity xormix32_x7s is
    generic (
        streams : integer range 1 to 32 := 1
    );
    port (
        
        -- clock and synchronous reset
        clk    : in std_logic;
        rst    : in std_logic;
        
        -- configuration
        seed_x : in std_logic_vector(31 downto 0);
        seed_y : in std_logic_vector(32 * streams - 1 downto 0);
        
        -- random number generator
        enable : in std_logic;
        result : out std_logic_vector(32 * streams - 1 downto 0)
        
    );
end xormix32_x7s;

architecture rtl of xormix32_x7s is
    
    constant lutval_xor5 : bit_vector(31 downto 0) := x"96696996";
    constant lutval_xor6 : bit_vector(63 downto 0) := x"6996966996696996";
    constant lutval_mix0 : bit_vector(63 downto 0) := x"59a6a659a65959a6";
    constant lutval_mix1 : bit_vector(63 downto 0) := x"a65959a659a6a659";
    
    function select_lutval_mix(
        bit : std_logic
    ) return bit_vector is
    begin
        if bit = '0' then
            return lutval_mix0;
        else
            return lutval_mix1;
        end if;
    end select_lutval_mix;
    
    type matrix_t is array(0 to 15, 0 to 10) of integer range 0 to 31;
    constant matrix : matrix_t := (
        (11, 24, 22,  3, 19, 25,  7, 20,  2, 26, 28),
        ( 8,  5, 18, 24,  4,  8, 22, 26,  7, 21, 14),
        (30, 26, 25, 14, 24, 21, 10, 16, 13,  5, 17),
        (14, 29, 24, 11, 25,  5, 26, 31, 22, 27,  7),
        ( 0, 17,  1, 18,  8, 29,  0, 21, 26,  3, 13),
        (23, 29, 19, 21, 10, 19, 20,  4, 18, 15, 10),
        (28, 29, 24, 19,  4, 19,  6, 27, 12, 11,  7),
        ( 1,  5,  3, 30, 25, 22, 12, 11,  7, 28,  1),
        (16,  5, 29,  2, 14,  8, 24,  0, 23, 31, 26),
        (15, 17,  4,  9,  6, 30,  9, 18,  2, 11,  6),
        ( 2, 27, 15, 12, 20, 21, 20, 10,  6, 31,  1),
        ( 9, 29, 15, 27, 16, 29, 10, 31, 30, 13,  3),
        (31, 23,  6, 24, 17,  4,  8,  6, 19, 16,  9),
        (23, 22, 15, 28,  6, 30,  9, 10, 28, 18, 15),
        (25, 20, 19, 12, 28, 13, 10,  9,  8,  0, 14),
        (22, 27,  3, 13, 23, 12,  2, 16,  1, 17, 23)
    );
    
    type salts_t is array(0 to 31) of std_logic_vector(31 downto 0);
    constant salts : salts_t := (
        x"198f8d32", x"46d9b8ac", x"57f90206", x"cb246290",
        x"5fda94c2", x"b9969e83", x"990053fe", x"0cef1f8b",
        x"9baafefa", x"232b8463", x"0fc77197", x"d113a2d8",
        x"d6c99ef7", x"f3fb7189", x"9ceeb1dd", x"352df180",
        x"feed780c", x"ee211518", x"3afaca18", x"95f13c50",
        x"d8449f2a", x"59752549", x"854f0980", x"234a07b4",
        x"51c0c69b", x"a71d489e", x"618cbc79", x"ab0e51e1",
        x"965c4507", x"e90488a4", x"73674eb7", x"00af1456"
    );
    
    type shuffle_t is array(0 to 31) of integer range 0 to 31;
    constant shuffle : shuffle_t := (
        15, 29,  5,  0, 16,  9, 26, 14,
        13, 10, 19, 11,  2,  6,  8, 17,
        20,  4, 22, 30, 31, 21, 24, 25,
        18, 27, 28, 23, 12,  7,  1,  3
    );
    
    signal r_state_x : std_logic_vector(31 downto 0);
    signal r_state_y : std_logic_vector(32 * streams - 1 downto 0);
    
    signal state_x_next : std_logic_vector(31 downto 0);
    signal state_y_next : std_logic_vector(32 * streams - 1 downto 0);
    
    type state_sr_t is array(0 to streams - 1) of std_logic_vector(63 downto 0);
    signal state_sr : state_sr_t;
    
begin
    
    result <= r_state_y;
    
    gen_bits: for i in 0 to 15 generate
        lut_xor5: LUT5 generic map (
            INIT => lutval_xor5
        ) port map (
            O => state_x_next(2 * i),
            I0 => r_state_x(matrix(i, 0)),
            I1 => r_state_x(matrix(i, 1)),
            I2 => r_state_x(matrix(i, 2)),
            I3 => r_state_x(matrix(i, 3)),
            I4 => r_state_x(matrix(i, 4))
        );
        lut_xor6: LUT6 generic map (
            INIT => lutval_xor6
        ) port map (
            O => state_x_next(2 * i + 1),
            I0 => r_state_x(matrix(i, 5)),
            I1 => r_state_x(matrix(i, 6)),
            I2 => r_state_x(matrix(i, 7)),
            I3 => r_state_x(matrix(i, 8)),
            I4 => r_state_x(matrix(i, 9)),
            I5 => r_state_x(matrix(i, 10))
        );
    end generate;
    
    gen_stream: for i in 0 to streams - 1 generate
        constant k : integer := (i + 1) mod streams;
    begin
        state_sr(i)(31 downto 0) <= r_state_y(32 * i + 31 downto 32 * i);
        gen_bit: for j in 0 to 31 generate
            constant l : integer := (i + shuffle(j)) mod 32;
        begin
            lut_mix: LUT6 generic map (
                INIT => select_lutval_mix(salts(i)(l))
            ) port map (
                O => state_sr(i)(j + 32),
                I0 => state_sr(k)(j),
                I1 => state_sr(k)(j + 6),
                I2 => state_sr(k)(j + 16),
                I3 => state_sr(k)(j + 9),
                I4 => state_sr(k)(j + 15),
                I5 => r_state_x(l)
            );
        end generate;
        state_y_next(32 * i + 31 downto 32 * i) <= state_sr(i)(63 downto 32);
    end generate;
    
    process (clk)
    begin
        if rising_edge(clk) then
            if rst = '1' then
                r_state_x <= seed_x;
                r_state_y <= seed_y;
            elsif enable = '1' then
                r_state_x <= state_x_next;
                r_state_y <= state_y_next;
            end if;
        end if;
    end process;
    
end rtl;
