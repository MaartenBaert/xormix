-- Copyright (c) 2020-2021 Maarten Baert <info@maartenbaert.be>
-- Available under the MIT License - see LICENSE.txt for details.

-- This file was generated by `generate_vhdl_x7s.py`.
-- This is a non-portable implementation optimized for Xilinx 7-Series FPGAs.
-- Revision: 1

library ieee;
use ieee.std_logic_1164.all;

library unisim;
use unisim.vcomponents.all;

entity xormix48_x7s is
    generic (
        streams : integer range 1 to 48 := 1
    );
    port (
        
        -- clock and synchronous reset
        clk    : in std_logic;
        rst    : in std_logic;
        
        -- configuration
        seed_x : in std_logic_vector(47 downto 0);
        seed_y : in std_logic_vector(48 * streams - 1 downto 0);
        
        -- random number generator
        enable : in std_logic;
        result : out std_logic_vector(48 * streams - 1 downto 0)
        
    );
end xormix48_x7s;

architecture rtl of xormix48_x7s is
    
    constant lutval_xor5 : bit_vector(31 downto 0) := x"96696996";
    constant lutval_xor6 : bit_vector(63 downto 0) := x"6996966996696996";
    constant lutval_mix0 : bit_vector(63 downto 0) := x"59a6a659a65959a6";
    constant lutval_mix1 : bit_vector(63 downto 0) := x"a65959a659a6a659";
    
    function select_lutval_mix(
        bit : std_logic
    ) return bit_vector is
    begin
        if bit = '0' then
            return lutval_mix0;
        else
            return lutval_mix1;
        end if;
    end select_lutval_mix;
    
    type matrix_t is array(0 to 23, 0 to 10) of integer range 0 to 47;
    constant matrix : matrix_t := (
        (22, 15, 43,  7, 11, 42, 14, 12, 35, 11, 17),
        (15, 31, 24, 44, 47, 26, 32, 47, 21, 35, 11),
        ( 6, 46, 36,  4, 33, 33, 19, 24, 32,  3, 38),
        ( 1, 38, 47, 16, 21, 25, 28, 29, 24, 35, 43),
        (34,  5, 41,  3,  0, 37, 34, 22,  2, 13, 14),
        (45,  1, 40,  8, 17, 20, 41,  9, 23, 32, 24),
        ( 4, 23, 25,  5, 35,  8, 19, 14, 28, 44, 26),
        ( 3, 10, 35, 46, 12, 15,  2, 35, 31, 43, 29),
        ( 6,  5, 11,  8, 20, 28, 10, 37, 24, 35,  5),
        (31, 42, 17, 45, 21, 42, 45, 36,  9, 31, 28),
        (27, 39, 19,  0, 38, 14, 40, 16,  9, 25, 18),
        (20, 27,  2, 45, 42, 44, 40, 20,  3, 25,  7),
        (16, 22, 39,  8, 13,  4, 46, 38, 33, 40, 26),
        (13,  6, 47,  2,  7, 27, 28, 10, 32,  0, 12),
        (36,  3, 26, 39, 30, 39, 12, 21, 38, 46, 30),
        ( 9, 41, 27, 12, 18, 45, 12, 47,  1,  3, 23),
        (24, 25, 29, 20, 18, 31,  2, 45, 11, 25, 30),
        (17,  7, 10, 34, 44,  4, 27,  0, 41, 43, 17),
        ( 5, 17, 46, 44, 39,  4, 42,  0,  6, 23, 22),
        (40, 43,  7,  6, 29, 23, 29, 43, 32, 36, 14),
        ( 0, 13, 15, 16, 25, 19, 30, 16,  6, 36, 44),
        (37,  4, 23, 41, 13, 33, 22, 19, 41, 28, 37),
        (24, 34,  5,  1,  9, 27, 37, 33, 32,  7, 47),
        (41, 10, 15,  8, 42,  8, 18, 19,  3, 10, 37)
    );
    
    type salts_t is array(0 to 47) of std_logic_vector(47 downto 0);
    constant salts : salts_t := (
        x"dc2a970723c9", x"e3e9a7b5f00f", x"368fddfe10b2", x"75cf3224f670",
        x"adc3319ee962", x"c9fdd5da7238", x"838aa6d68e51", x"34504e889c4e",
        x"16f61844dd41", x"316767a3bcb6", x"4f2b4ee6a079", x"8a9ef2995097",
        x"8f8919a04ad3", x"54d0862260f6", x"59bf4852d6de", x"e182ee2c64dc",
        x"117087d44a4c", x"2de1ba749c87", x"4db37369078b", x"c4d0b2be2d19",
        x"fe1e25f4f213", x"11f41b1ba06e", x"0f2cf602d40a", x"1a4f0b78edd2",
        x"0635bdf9a9a1", x"e6066341f129", x"d63a2e6c6b6e", x"3f0b1417a83e",
        x"aa5f9fc3447b", x"fd4ca29740b2", x"d307b0424a1f", x"377cf18c8a09",
        x"4ae1ee2f8ff1", x"6470f197fbcc", x"93fb56272e46", x"b8ff040d894b",
        x"7de7947afb4b", x"8c2c614e379f", x"981e3a7298fb", x"1d16c2d1672f",
        x"3e8785982f5c", x"e92ab1204c26", x"f7c8549141c1", x"109c81c9df19",
        x"9379f90a2ff8", x"583491406df0", x"00302447d0cf", x"34c3236725e9"
    );
    
    type shuffle_t is array(0 to 47) of integer range 0 to 47;
    constant shuffle : shuffle_t := (
         8, 23,  2, 15, 46, 31, 22, 12,
        27, 17,  9, 39, 42, 19, 28, 45,
         1,  0, 41, 30,  3, 38, 25, 29,
        24,  5, 32, 44, 26, 21, 37, 34,
        13, 18, 35,  6, 11, 36, 43,  7,
        40, 33, 20, 10, 47,  4, 14, 16
    );
    
    signal r_state_x : std_logic_vector(47 downto 0);
    signal r_state_y : std_logic_vector(48 * streams - 1 downto 0);
    
    signal state_x_next : std_logic_vector(47 downto 0);
    signal state_y_next : std_logic_vector(48 * streams - 1 downto 0);
    
    type state_sr_t is array(0 to streams - 1) of std_logic_vector(95 downto 0);
    signal state_sr : state_sr_t;
    
begin
    
    result <= r_state_y;
    
    gen_bits: for i in 0 to 23 generate
        lut_xor5: LUT5 generic map (
            INIT => lutval_xor5
        ) port map (
            O => state_x_next(2 * i),
            I0 => r_state_x(matrix(i, 0)),
            I1 => r_state_x(matrix(i, 1)),
            I2 => r_state_x(matrix(i, 2)),
            I3 => r_state_x(matrix(i, 3)),
            I4 => r_state_x(matrix(i, 4))
        );
        lut_xor6: LUT6 generic map (
            INIT => lutval_xor6
        ) port map (
            O => state_x_next(2 * i + 1),
            I0 => r_state_x(matrix(i, 5)),
            I1 => r_state_x(matrix(i, 6)),
            I2 => r_state_x(matrix(i, 7)),
            I3 => r_state_x(matrix(i, 8)),
            I4 => r_state_x(matrix(i, 9)),
            I5 => r_state_x(matrix(i, 10))
        );
    end generate;
    
    gen_stream: for i in 0 to streams - 1 generate
        constant k : integer := (i + 1) mod streams;
    begin
        state_sr(i)(47 downto 0) <= r_state_y(48 * i + 47 downto 48 * i);
        gen_bit: for j in 0 to 47 generate
            constant l : integer := (i + shuffle(j)) mod 48;
        begin
            lut_mix: LUT6 generic map (
                INIT => select_lutval_mix(salts(i)(l))
            ) port map (
                O => state_sr(i)(j + 48),
                I0 => state_sr(k)(j),
                I1 => state_sr(k)(j + 19),
                I2 => state_sr(k)(j + 21),
                I3 => state_sr(k)(j + 15),
                I4 => state_sr(k)(j + 22),
                I5 => r_state_x(l)
            );
        end generate;
        state_y_next(48 * i + 47 downto 48 * i) <= state_sr(i)(95 downto 48);
    end generate;
    
    process (clk)
    begin
        if rising_edge(clk) then
            if rst = '1' then
                r_state_x <= seed_x;
                r_state_y <= seed_y;
            elsif enable = '1' then
                r_state_x <= state_x_next;
                r_state_y <= state_y_next;
            end if;
        end if;
    end process;
    
end rtl;

